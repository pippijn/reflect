#!/usr/bin/env perl

use common::sense;

use constant USAGE => "Usage: astgen <rule-file>";

our $dataname;

my @vfuns = qw/destruct print/;

my $rules = do {
   my $file = $ARGV[0]
      or die USAGE;
   require $file
};

my $DATANAME = uc $dataname;

sub maybe_open {
   my ($name) = @_;

   open my $fh, ">", $name
      || die "Could not open $name: $!"
         unless -f $name;

   $fh
}


sub all {
   my ($members) = @_;

   map { ref $_ eq "ARRAY" ? @$_ : $_ } @$members;
}

sub required {
   my ($members) = @_;

   grep { ref $_ ne "ARRAY" } @$members;
}


sub gen_header_internal {
   my ($file, $name, $members) = @_;

   my $fh = maybe_open "src/$dataname/gen/$file.h"
      or return;

   print $fh <<EOF;
struct ${dataname}_node_$name
{
  ${dataname}_node base;

EOF

   print $fh "  ${dataname}_node *$_;\n"
      for all $members;
    
   my $ctor = "void ${dataname}_${name}_construct ";
   print $fh <<EOF;
};


extern struct ${dataname}_vtbl const ${dataname}_${name}_vtbl;


$ctor( struct ${dataname}_node_${name} *self
EOF

   print $fh ' ' x (length $ctor) . ", ${dataname}_node *$_\n"
      for all $members;
   print $fh ' ' x (length $ctor) . ");\n";
}


sub gen_header {
   my ($file, $name, $members) = @_;

   my $fh = maybe_open "include/${dataname}/gen/$file.h"
      or return;

   print $fh "/*\n * ";
   print $fh do { my $spaced = $name; $spaced =~ s/_/ /g; $spaced };
   print $fh "\n */\n\n";

   print $fh "/* constructor */\n";
   my $new = "${dataname}_node *${dataname}_${name}_new ";
   if ($#$members) {
      print $fh "$new( ";
      print $fh join ' ' x (length $new) . ", ", map { "${dataname}_node *$_\n" } all $members;
      print $fh ' ' x (length $new) . ");\n\n";
   } else {
      print $fh "$new(${dataname}_node *$members->[0]);\n\n";
   }

   print $fh "/* accessors */\n";
   print $fh "${dataname}_node *${dataname}_${name}_$_ (${dataname}_node const *self);\n"
      for all $members;
}


sub gen_source {
   my ($file, $name, $members) = @_;

   my $fh = maybe_open "src/${dataname}/gen/$file.c"
      or return;

   my $NAME = uc $name;

   print $fh <<EOF;
#include "../internal.h"

/* type of *self */

typedef struct ${dataname}_node_${name} self_type;


/* vtable */

EOF

   print $fh "static fn_$_ ${dataname}_${name}_$_;\n"
      for @vfuns;

   print $fh <<EOF;

static struct ${dataname}_vtbl const* const vtbl = &${dataname}_${name}_vtbl;
struct ${dataname}_vtbl const ${dataname}_${name}_vtbl = {
  {
    &${dataname}_node_vtbl,
    "$name",
    ${DATANAME}_$NAME,
    sizeof (self_type),
  },
EOF
   print $fh "  ${dataname}_${name}_$_,\n"
      for @vfuns;
   print $fh "};\n";

   my $ctor = "${dataname}_${name}_construct ";
   print $fh <<EOF;


/* internal */

void
$ctor( self_type *self
EOF
   print $fh ' ' x (length $ctor) . ", ${dataname}_node *$_\n"
      for all $members;
   print $fh ' ' x (length $ctor) . ")\n";
   print $fh "{";
   print $fh "\n  struct location loc;";
   print $fh "\n  ${dataname}_node* fst = NULL;";
   print $fh "\n  ${dataname}_node* lst = NULL;";
   print $fh "\n\n";

   print $fh "  assert ($_ != NULL);\n"
      for required $members;

   for (all $members) {
      print $fh <<EOF;
  if ($_ != NULL)
    {
      lst = $_;
      if (fst == NULL)
        fst = $_;
    }
EOF
   }
   print $fh "\n  COMPUTE_LOC (fst, lst);";
   print $fh "\n  BASE_CTOR (node, &loc);\n";
   #print $fh "\n  self->$_ = ${dataname}_node_ref_ornull ($_);"
   print $fh "\n  self->$_ = $_;"
      for all $members;
   print $fh "\n}\n";


   my $new = "${dataname}_${name}_new ";
   print $fh <<EOF;


/* public */

${dataname}_node *
EOF
   my $new = "${dataname}_${name}_new ";
   if ($#$members) {
      print $fh "$new( ";
      print $fh join ' ' x (length $new) . ", ", map { "${dataname}_node *$_\n" } all $members;
      print $fh ' ' x (length $new) . ")\n";
   } else {
      print $fh "$new(${dataname}_node *$members->[0])\n";
   }
   print $fh "{\n  return NEW ($name, " . (join ", ", all $members) . ");\n}\n";


   print $fh "\n\n/* accessors */\n\n";
   print $fh "ACCESSOR ($name, $_)\n"
      for all $members;


   print $fh <<EOF;


/* virtual */

void
${dataname}_${name}_destruct (${dataname}_node *object)
{
  SELF ();

EOF

   print $fh "  ${dataname}_node_unref_ornull (self->$_); self->$_ = NULL;\n"
      for all $members;

   print $fh <<EOF;

  BASE_DTOR ();
}
EOF


   print $fh <<EOF;

void
${dataname}_${name}_print (${dataname}_node const *object, FILE *fh)
{
  CONST_SELF ();

EOF
   print $fh "  fprintf (fh, \"<$name>\\n\");\n";
   for my $member (@$members) {
      if (ref $member eq "ARRAY") {
         for my $mem (@$member) {
            print $fh "  if (self->$mem != NULL)\n";
            print $fh "    {\n";
            print $fh "      fprintf (fh, \"<$mem>\\n\");\n";
            print $fh "      ${dataname}_node_print (self->$mem, fh);\n";
            print $fh "      fprintf (fh, \"</$mem>\\n\");\n";
            print $fh "    }\n";
         }
      } else {
         print $fh "  fprintf (fh, \"<$member>\\n\");\n";
         print $fh "  ${dataname}_node_print (self->$member, fh);\n";
         print $fh "  fprintf (fh, \"</$member>\\n\");\n";
      }
   }
   print $fh "  fprintf (fh, \"</$name>\\n\");\n";
   print $fh "}\n";
}


open my $nodes_h, ">", "include/${dataname}/gen/nodes.h"
   or die $!;
open my $internal_nodes_h, ">", "src/${dataname}/gen/nodes.h"
   or die $!;
open my $internal_kinds_h, ">", "src/${dataname}/gen/kinds.h"
   or die $!;

print "  ASTGEN  $ARGV[0]\n";

for my $file (sort keys %$rules) {
   print $nodes_h "#include <${dataname}/gen/$file.h>\n";
   print $internal_nodes_h "#include \"$file.h\"\n";
   print $internal_kinds_h "  ${DATANAME}_" . (uc $rules->{$file}[0]) . ",\n";
   gen_header_internal $file, @{ $rules->{$file} };
   gen_header          $file, @{ $rules->{$file} };
   gen_source          $file, @{ $rules->{$file} };
}
