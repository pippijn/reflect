#!/usr/bin/env perl

use common::sense;

use constant USAGE => "Usage: astgen <rule-file>";

my @vfuns = qw/destruct print/;

my $rules = do {
   my $file = $ARGV[0]
      or die USAGE;
   require $file
};

sub maybe_open {
   my ($name) = @_;

   open my $fh, ">", $name
      || die "Could not open $name: $!"
         unless -f $name;

   $fh
}


sub all {
   my ($members) = @_;

   map { ref $_ eq "ARRAY" ? @$_ : $_ } @$members;
}

sub required {
   my ($members) = @_;

   grep { ref $_ ne "ARRAY" } @$members;
}


sub gen_header_internal {
   my ($file, $name, $members) = @_;

   my $fh = maybe_open "src/ast/gen/$file.h"
      or return;

   print $fh <<EOF;
struct ast_node_$name
{
  ast_node base;

EOF

   print $fh "  ast_node *$_;\n"
      for all $members;
    
   my $ctor = "void ast_${name}_construct ";
   print $fh <<EOF;
};


extern struct ast_vtbl const ast_${name}_vtbl;


$ctor( struct ast_node_${name} *self
EOF

   print $fh ' ' x (length $ctor) . ", ast_node *$_\n"
      for all $members;
   print $fh ' ' x (length $ctor) . ");\n";
}


sub gen_header {
   my ($file, $name, $members) = @_;

   my $fh = maybe_open "include/ast/gen/$file.h"
      or return;

   print $fh "/*\n * ";
   print $fh do { my $spaced = $name; $spaced =~ s/_/ /g; $spaced };
   print $fh "\n */\n\n";

   print $fh "/* constructor */\n";
   my $new = "ast_node *ast_${name}_new ";
   if ($#$members) {
      print $fh "$new( ";
      print $fh join ' ' x (length $new) . ", ", map { "ast_node *$_\n" } all $members;
      print $fh ' ' x (length $new) . ");\n\n";
   } else {
      print $fh "$new(ast_node *$members->[0]);\n\n";
   }

   print $fh "/* accessors */\n";
   print $fh "ast_node *ast_${name}_$_ (ast_node const *self);\n"
      for all $members;
}


sub gen_source {
   my ($file, $name, $members) = @_;

   my $fh = maybe_open "src/ast/gen/$file.c"
      or return;

   my $NAME = $name;
   $NAME =~ tr/a-z/A-Z/;

   print $fh <<EOF;
#include "../internal.h"

/* type of *self */

typedef struct ast_node_${name} self_type;


/* vtable */

EOF

   print $fh "static fn_$_ ast_${name}_$_;\n"
      for @vfuns;

   print $fh <<EOF;

static struct ast_vtbl const* const vtbl = &ast_${name}_vtbl;
struct ast_vtbl const ast_${name}_vtbl = {
  {
    &ast_node_vtbl,
    "$name",
    AST_$NAME,
    sizeof (struct ast_node_$name),
  },
EOF
   print $fh "  ast_${name}_$_,\n"
      for @vfuns;
   print $fh "};\n";

   my $ctor = "ast_${name}_construct ";
   print $fh <<EOF;


/* internal */

void
$ctor( self_type *self
EOF
   print $fh ' ' x (length $ctor) . ", ast_node *$_\n"
      for all $members;
   print $fh ' ' x (length $ctor) . ")\n";
   print $fh "{";
   print $fh "\n  struct location loc;";
   print $fh "\n  ast_node* fst = NULL;";
   print $fh "\n  ast_node* lst = NULL;";
   print $fh "\n\n";

   print $fh "  assert ($_ != NULL);\n"
      for required $members;

   for (all $members) {
      print $fh <<EOF;
  if ($_ != NULL)
    {
      lst = $_;
      if (fst == NULL)
        fst = $_;
    }
EOF
   }
   print $fh "\n  COMPUTE_LOC (fst, lst);";
   print $fh "\n  BASE_CTOR (node, &loc);\n";
   #print $fh "\n  self->$_ = ast_node_ref_ornull ($_);"
   print $fh "\n  self->$_ = $_;"
      for all $members;
   print $fh "\n}\n";


   my $new = "ast_${name}_new ";
   print $fh <<EOF;


/* public */

ast_node *
EOF
   my $new = "ast_${name}_new ";
   if ($#$members) {
      print $fh "$new( ";
      print $fh join ' ' x (length $new) . ", ", map { "ast_node *$_\n" } all $members;
      print $fh ' ' x (length $new) . ")\n";
   } else {
      print $fh "$new(ast_node *$members->[0])\n";
   }
   print $fh "{\n  return NEW ($name, " . (join ", ", all $members) . ");\n}\n";


   print $fh "\n\n/* accessors */\n\n";
   print $fh "ACCESSOR ($name, $_)\n"
      for all $members;


   print $fh <<EOF;


/* virtual */

void
ast_${name}_destruct (ast_node *object)
{
  SELF ();

EOF

   print $fh "  ast_node_unref_ornull (self->$_); self->$_ = NULL;\n"
      for all $members;

   print $fh <<EOF;

  BASE_DTOR ();
}
EOF


   print $fh <<EOF;

void
ast_${name}_print (ast_node const *object, FILE *fh)
{
  CONST_SELF ();

EOF
   print $fh "  fprintf (fh, \"<$name>\\n\");\n";
   for my $member (@$members) {
      if (ref $member eq "ARRAY") {
         for my $mem (@$member) {
            print $fh "  if (self->$mem != NULL)\n";
            print $fh "    {\n";
            print $fh "      fprintf (fh, \"<$mem>\\n\");\n";
            print $fh "      ast_node_print (self->$mem, fh);\n";
            print $fh "      fprintf (fh, \"</$mem>\\n\");\n";
            print $fh "    }\n";
         }
      } else {
         print $fh "  fprintf (fh, \"<$member>\\n\");\n";
         print $fh "  ast_node_print (self->$member, fh);\n";
         print $fh "  fprintf (fh, \"</$member>\\n\");\n";
      }
   }
   print $fh "  fprintf (fh, \"</$name>\\n\");\n";
   print $fh "}\n";
}


open my $nodes_h, ">", "include/ast/gen/nodes.h"
   or die $!;
open my $internal_nodes_h, ">", "src/ast/gen/nodes.h"
   or die $!;
open my $internal_kinds_h, ">", "src/ast/gen/kinds.h"
   or die $!;

print "  ASTGEN  $ARGV[0]\n";

for my $file (sort keys %$rules) {
   print $nodes_h "#include <ast/gen/$file.h>\n";
   print $internal_nodes_h "#include \"$file.h\"\n";
   print $internal_kinds_h "  AST_" . (uc $rules->{$file}[0]) . ",\n";
   gen_header_internal $file, @{ $rules->{$file} };
   gen_header          $file, @{ $rules->{$file} };
   gen_source          $file, @{ $rules->{$file} };
}
