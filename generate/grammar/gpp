#!/usr/bin/env perl

use common::sense;
use generate::grammar::parse::parse;

my $dataname = $main::dataname = "pt";

my $rules = parse $ARGV[0] || die "Usage: $0 <rules.y>";

use Data::Dumper;
#print Dumper $rules;
#exit;

sub locate_args {
   my ($rules) = @_;

   my %inv;
   for (@$rules) {
      push @{ $inv{$_->{node}} }, $_->{rhs};
   }

   my %nodes;
   while (my ($node, $rule) = each %inv) {
      for my $rhs (@$rule) {
         my $i = 1;
         for my $arg (@$rhs) {
            if ($nodes{$node}{$arg->{name}} < $i) {
               $nodes{$node}{$arg->{name}} = $i
            }
            ++$i;
         }
      }
   }

   \%nodes
}

sub assemble {
   my ($nodes, $rule) = @_;

   my $rhs = join ' ', map { $_->{expr} } @{ $rule->{rhs} };
   my $code = "\n\t  { \$\$ = ${dataname}_$rule->{node}_new (";

   my @args;
   for my $i (0 .. $#{ $rule->{rhs} }) {
      my $arg  = $rule->{rhs}[$i]{name};
      my $node = $rule->{node};
      my $idx  = $nodes->{$node}{$arg};

      for ($i + 1 .. $idx - 1) {
         push @args, undef;
      }

      push @args, $arg;
   }
   for (@args + 1 .. keys %{ $nodes->{$rule->{node}} }) {
      push @args, undef;
   }

   my $count = 1;
   $code .= join ", ", map { $_ ? '$' . $count++ : "NULL" } @args;
   $code .= "); }";

   $rhs . $code
}

while (my ($nterm, $rule) = each %$rules) {
   my $nodes = locate_args $rule;

   print "$nterm\n\t: ";
   print join "\n\t| ", map { assemble $nodes, $_ } @$rule;
   print "\n\t;\n\n";
}

  #add_assign => ["n1", "n2", "n3"],
