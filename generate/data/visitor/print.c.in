#include <$dataname/visitors.h>
#include <$dataname/visitor/impl.h>

#include <libxml/tree.h>

typedef struct ${dataname}_print_visitor self_type;

struct ${dataname}_print_visitor
{
  ${dataname}_visitor base;

  xmlDocPtr doc;
  xmlNodePtr cur;
  FILE *fh;
};

[% FOREACH rule = rules %]
[% name = rule.value.0 %]
[% members = rule.value.1 %]

static void
${dataname}_print_visitor_visit_${name} (visitor_type *object, node_type const *node)
{
  SELF ();
  xmlNodePtr const last = self->cur;

  self->cur = xmlNewChild (self->cur, NULL, BAD_CAST "$name", NULL);

  [% FOREACH member = members %]
    [% IF member.optional %]
      [% FOREACH mem = member %]

  if (${dataname}_${name}_${mem} (node) != NULL)
    {
      xmlNodePtr const last = self->cur;
      self->cur = xmlNewChild (self->cur, NULL, BAD_CAST "$mem", NULL);
      ${dataname}_node_accept (${dataname}_${name}_${mem} (node), &self->base);
      self->cur = last;
    }

      [% END %]
    [% ELSE %]

  {
    xmlNodePtr const last = self->cur;
    self->cur = xmlNewChild (self->cur, NULL, BAD_CAST "$member", NULL);
    ${dataname}_node_accept (${dataname}_${name}_${member} (node), &self->base);
    self->cur = last;
  }

    [% END %]
  [% END %]

  self->cur = last;
}

[% END %]


static xmlChar const *
xml_loc (int line, int column)
{
  static char buf[64];

  snprintf (buf, sizeof buf, "%d:%d", line, column);
  return BAD_CAST buf;
}

static void
${dataname}_print_visitor_visit_token (visitor_type *object, node_type const *node)
{
  SELF ();
  struct location const *loc = ${dataname}_node_location (node);

  xmlNodePtr xmltok = xmlNewChild (self->cur, NULL, BAD_CAST "token", BAD_CAST ${dataname}_token_text (node));
  xmlNewProp (xmltok, BAD_CAST "left",  xml_loc (loc->first_line, loc->first_column));
  xmlNewProp (xmltok, BAD_CAST "right", xml_loc (loc->last_line , loc->last_column ));
}


static struct ${dataname}_visitor_vtbl ${dataname}_print_visitor_vtbl = {
  {
    "${dataname}_visitor",
    sizeof (self_type),
  },
  ${dataname}_print_visitor_visit_token,

[% FOREACH rule = rules %]
[% name = rule.value.0 %]
  ${dataname}_print_visitor_visit_${name},

[% END %]
};

static void
${dataname}_print_visitor_construct (self_type *self, FILE *fh)
{
  assert (self != NULL);
  assert (fh != NULL);

  ${dataname}_visitor_construct (&self->base, &${dataname}_print_visitor_vtbl);

  self->doc = xmlNewDoc (BAD_CAST "1.0");
  self->cur = xmlNewNode (NULL, BAD_CAST "$dataname");
  self->fh = fh;

  xmlDocSetRootElement (self->doc, self->cur);
}

visitor_type *
${dataname}_print_visitor_new (FILE *fh)
{
  self_type *self = alloc (sizeof *self);

  ${dataname}_print_visitor_construct (self, fh);

  return &self->base;
}

void
${dataname}_print_visitor_delete (visitor_type *object)
{
  SELF ();

  /* TODO: give client code the option to get the document as string */
  xmlDocDump (self->fh, self->doc);
  xmlFreeDoc (self->doc);

  sever (self, self->base.vtbl->ti.size);
}
