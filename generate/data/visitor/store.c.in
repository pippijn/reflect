#include <$dataname/visitors.h>
#include <$dataname/visitor/impl.h>

#include "../../internal.h"

typedef struct ${dataname}_store_visitor self_type;

struct ${dataname}_store_visitor
{
  ${dataname}_visitor base;

  FILE *fh;
  int indent;
};

[% FOREACH rule = rules %]
[% name = rule.value.0 %]
[% members = rule.value.1 %]

static void
${dataname}_store_visitor_visit_$name (visitor_type *object, ${dataname}_node const *node)
{
  SELF ();

  INDENT (self->fh, self->indent);
  self->indent++;
  fprintf (self->fh, "(${name}\n");

  [% FOREACH member = members %]
    [% IF member.optional %]
      [% FOREACH mem = member %]

  if (${dataname}_${name}_${mem} (node) != NULL)
    {
      INDENT (self->fh, self->indent);
      self->indent++;
      fprintf (self->fh, "('$mem\n");
      ${dataname}_node_accept (${dataname}_${name}_${mem} (node), &self->base);
      self->indent--;
      INDENT (self->fh, self->indent);
      fprintf (self->fh, ")\n");
    }

      [% END %]
    [% ELSE %]

  INDENT (self->fh, self->indent);
  self->indent++;
  fprintf (self->fh, "('$member\n");
  ${dataname}_node_accept (${dataname}_${name}_${member} (node), &self->base);
  self->indent--;
  INDENT (self->fh, self->indent);
  fprintf (self->fh, ")\n");

    [% END %]
  [% END %]

  self->indent--;
  INDENT (self->fh, self->indent);
  fprintf (self->fh, ")\n");
}

[% END %]


#define strlen my_strlen
static size_t
my_strlen (char const *str)
{
  size_t sz = 0;

  while (*str++)
    ++sz;
  return sz;
}

static char const *
sexpr_escape (char const *text)
{
  static char buf[1024];
  char const* it = text;
  char const* et = text + strlen (text);
  char *p = buf;

  *p++ = '"';

  for (; it != et; it++)
    {
      if (*it == '"')
        *p++ = '\\';
      *p++ = *it;
    }

  *p++ = '"';
  *p = '\0';

  return buf;
}

static void
${dataname}_store_visitor_visit_token (visitor_type *object, node_type const *node)
{
  SELF ();
  struct location const *loc = ${dataname}_node_location (node);

  INDENT (self->fh, self->indent);
  fprintf ( self->fh
          , "((%d %d) (%d %d) %s)\n"
	  , loc->first_line, loc->first_column
	  , loc->last_line,  loc->last_column
	  , strcmp ("<empty>", ${dataname}_token_text (node)) == 0
	    ? "NIL"
	    : sexpr_escape (${dataname}_token_text (node))
	  );
}


static struct ${dataname}_visitor_vtbl ${dataname}_store_visitor_vtbl = {
  {
    "${dataname}_visitor",
    sizeof (self_type),
  },
  ${dataname}_store_visitor_visit_token,

[% FOREACH rule = rules %]
[% name = rule.value.0 %]
  ${dataname}_store_visitor_visit_${name},

[% END %]
};

static void
${dataname}_store_visitor_construct (self_type *self, FILE *fh, int indent)
{
  assert (self != NULL);
  assert (fh != NULL);
  assert (indent >= 0);

  ${dataname}_visitor_construct (&self->base, &${dataname}_store_visitor_vtbl);

  self->fh     = fh;
  self->indent = indent;
}

visitor_type *
${dataname}_store_visitor_new (FILE *fh, int indent)
{
  return NEW (store_visitor, fh, indent);
}

void
${dataname}_store_visitor_delete (visitor_type *object)
{
  SELF ();

  sever (self, self->base.vtbl->ti.size);
}
