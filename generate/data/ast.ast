# vim:ft=perl

$main::dataname = "ast";

{
   for_statement => ["for_tok", "lbrack", "initializer", "condition", ["increment"], "rbrack", "body"],
   while_statement => ["while_tok", "lbrack", "condition", "rbrack", "body"],
   do_statement => ["do_tok", "body", "while_tok", "lbrack", "condition", "rbrack", "semicolon"],
   switch_statement => ["switch_tok", "lbrack", "expr", "rbrack", "body"],
   if_statement => ["if_tok", "lbrack", "condition", "rbrack", "if_body", ["else_tok", "else_body"]],
   goto_statement => ["goto_tok", "label", "semicolon"],
   continue_statement => ["continue_tok", "semicolon"],
   break_statement => ["break_tok", "semicolon"],
   return_statement => ["return_tok", ["expr"], "semicolon"],
   enumerator => ["identifier", ["equals", "expr"]],
   label_statement => ["label", "colon", "statement"],
   case_label_statement => ["case_tok", "expr", "colon", "statement"],
   default_label_statement => ["default_tok", "colon", "statement"],
   const_type_qualifier => ["const_tok"],
   volatile_type_qualifier => ["volatile_tok"],
   typedef_str_class_spec => ["typedef_tok"],
   extern_str_class_spec => ["extern_tok"],
   static_str_class_spec => ["static_tok"],
   auto_str_class_spec => ["auto_tok"],
   register_str_class_spec => ["register_tok"],
   void_type_spec => ["void_tok"],
   char_type_spec => ["char_tok"],
   short_type_spec => ["short_tok"],
   int_type_spec => ["int_tok"],
   long_type_spec => ["long_tok"],
   float_type_spec => ["float_tok"],
   double_type_spec => ["double_tok"],
   signed_type_spec => ["signed_tok"],
   unsigned_type_spec => ["unsigned_tok"],
   expression_statement => [["expr"], "semicolon"],
   pre_increment => ["op", "expr"],
   pre_decrement => ["op", "expr"],
   address_of => ["op", "expr"],
   pointer_dereference => ["op", "expr"],
   positive => ["op", "expr"],
   negate => ["op", "expr"],
   bitwise_negate => ["op", "expr"],
   logical_not => ["op", "expr"],
   sizeof_var => ["op", "expr"],
   sizeof_type => ["op", "lbrack", "expr", "rbrack"],
   array_access => ["expr", "lsqbrack", "idx", "rsqbrack"],
   function_call => ["expr", "lbrack", ["arglist"], "rbrack"],
   struct_access => ["expr", "op", "identifier"],
   pointer_access => ["expr", "op", "identifier"],
   post_increment => ["expr", "op"],
   post_decrement => ["expr", "op"],
   variable => ["identifier"],
   constant => ["constant"],
   string_literal => ["string"],
   bracket_expression => ["lbrack", "expr", "rbrack"],
   type_cast => ["lbrack", "type", "rbrack", "expr"],
   multiply => ["factor1", "op", "factor2"],
   divide => ["dividend", "op", "divisor"],
   modulo => ["dividend", "op", "divisor"],
   add => ["summand1", "op", "summand2"],
   subtract => ["minuend", "op", "subtrahend"],
   left_shift => ["expr", "op", "amount"],
   right_shift => ["expr", "op", "amount"],
   less_than => ["expr1", "op", "expr2"],
   greater_than => ["expr1", "op", "expr2"],
   less_than_equals => ["expr1", "op", "expr2"],
   greater_than_equals => ["expr1", "op", "expr2"],
   equals => ["expr1", "op", "expr2"],
   not_equals => ["expr1", "op", "expr2"],
   bitwise_and => ["expr1", "op", "expr2"],
   bitwise_xor => ["expr1", "op", "expr2"],
   bitwise_or => ["expr1", "op", "expr2"],
   logical_and => ["expr1", "op", "expr2"],
   logical_or => ["expr1", "op", "expr2"],
   ternary_op => ["condition", "op_quest", "then_expr", "op_colon", "else_expr"],
   assign => ["lvalue", "op", "expr"],
   multiply_assign => ["lvalue", "op", "expr"],
   divide_assign => ["lvalue", "op", "expr"],
   modulo_assign => ["lvalue", "op", "expr"],
   add_assign => ["lvalue", "op", "expr"],
   subtract_assign => ["lvalue", "op", "expr"],
   left_shift_assign => ["lvalue", "op", "expr"],
   right_shift_assign => ["lvalue", "op", "expr"],
   and_assign => ["lvalue", "op", "expr"],
   xor_assign => ["lvalue", "op", "expr"],
   or_assign => ["lvalue", "op", "expr"],
   comma => ["expr1", "op", "expr2"],
   struct => ["struct_tok"],
   union => ["union_tok"],
   defined_enum_spec => ["enum_tok", ["identifier"], "lbrace", "enum_list", "rbrace"],
   referenced_enum_spec => ["enum_tok", "identifier"],
   struct_definition_spec => ["struct_tok", ["identifier"], ["lbrace", "struct_list", "rbrace"]],
   declarator => [["pointer"], "direct_decl"],
   declaration => ["decl_specifier", ["init_list"], "semicolon"],
   storage_decl_spec => ["storage_class_spec", ["decl_spec"]],
   type_spec_decl_spec => ["type_spec", ["decl_spec"]],
   type_qual_decl_spec => ["type_qual", ["decl_spec"]],
   init_declr => ["decl", ["op", "init"]],
   struct_declaration => ["spec_qual_list", "struct_decl_list"],
   pointer => ["op", ["type_qual_list"], ["pointer"]],
   bitfield_declarator => [["decl"], ["colon", "const_expr"]],
   function_definition => [["return_type"], "name", ["arg_list"], "body"],
   compound_statement => ["lbrace", ["declarations"], ["body"], "rbrace"],
   abstract_declarator => [["pointer"], ["direct_abstr_decl"]],
   type_name => ["spec_qual_list", ["abstr_decl"]],
   parameter_type_list => ["param_list", ["comma", "ellipsis"]],
}
